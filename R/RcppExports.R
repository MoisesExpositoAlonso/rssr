# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

betavar <- function(p, mu, s) {
    .Call('rssr_betavar', PACKAGE = 'rssr', p, mu, s)
}

intklbeta_rssbvsr <- function(alpha, mu, sigma_square, sigma_beta_square) {
    .Call('rssr_intklbeta_rssbvsr', PACKAGE = 'rssr', alpha, mu, sigma_square, sigma_beta_square)
}

intgamma <- function(logodds, alpha) {
    .Call('rssr_intgamma', PACKAGE = 'rssr', logodds, alpha)
}

rel_err <- function(p0, p1) {
    .Call('rssr_rel_err', PACKAGE = 'rssr', p0, p1)
}

find_maxerr <- function(alpha, alpha0, r, r0) {
    .Call('rssr_find_maxerr', PACKAGE = 'rssr', alpha, alpha0, r, r0)
}

calculate_lnZ <- function(q, r, SiRiSr, logodds, sesquare, alpha, mu, s, sigb) {
    .Call('rssr_calculate_lnZ', PACKAGE = 'rssr', q, r, SiRiSr, logodds, sesquare, alpha, mu, s, sigb)
}

wrap_rss_varbvsr_iter <- function(SiRiS, sigma_beta, logodds, betahat, se, alpha, mu, SiRiSr, reverse) {
    .Call('rssr_wrap_rss_varbvsr_iter', PACKAGE = 'rssr', SiRiS, sigma_beta, logodds, betahat, se, alpha, mu, SiRiSr, reverse)
}

#' Run RSS with the variational bayes algorithm accelerated with SQUAREM
#' @template rssr
#' @param talpha0 a length p vector specifying the initial value of alpha
#' @param tmu0 a length p vector specifying the initial value of mu
#' @param SiRiSr0 a length p vector specifying the initial value of SiRiSr
#' @useDynLib rssr
rss_varbvsr_squarem <- function(SiRiS, sigma_beta, logodds, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, verbose, lnz_tol) {
    .Call('rssr_rss_varbvsr_squarem', PACKAGE = 'rssr', SiRiS, sigma_beta, logodds, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, verbose, lnz_tol)
}

rss_varbvsr_naive <- function(SiRiS, sigma_beta, logodds, betahat, se, alpha0, mu0, SiRiSr0, tolerance) {
    .Call('rssr_rss_varbvsr_naive', PACKAGE = 'rssr', SiRiS, sigma_beta, logodds, betahat, se, alpha0, mu0, SiRiSr0, tolerance)
}

#' Run RSS with the variational bayes algorithm accelerated with SQUAREM, only returning the lower bound
#' @template rssr
#' @param talpha0 a length p vector specifying the initial value of alpha
#' @param tmu0 a length p vector specifying the initial value of mu
#' @param SiRiSr0 a length p vector specifying the initial value of SiRiSr
#' @useDynLib rssr
rss_varbvsr_squarem_iter <- function(SiRiS, sigma_beta, logodds, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, lnz_tol) {
    .Call('rssr_rss_varbvsr_squarem_iter', PACKAGE = 'rssr', SiRiS, sigma_beta, logodds, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, lnz_tol)
}

wrap_rss_varbvs_squarem_optim <- function(par, SiRiS, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, lnz_tol) {
    .Call('rssr_wrap_rss_varbvs_squarem_optim', PACKAGE = 'rssr', par, SiRiS, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, lnz_tol)
}

grid_search_rss_varbvsr <- function(SiRiS, sigma_beta, logodds, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, verbose, lnz_tol) {
    .Call('rssr_grid_search_rss_varbvsr', PACKAGE = 'rssr', SiRiS, sigma_beta, logodds, betahat, se, talpha0, tmu0, tSiRiSr0, tolerance, itermax, verbose, lnz_tol)
}

rss_varbvsr_update <- function(betahat, se, sigma_beta, SiRiS_snp, SiRiSr, SiRiSr_snp, logodds, alpha, mu) {
    invisible(.Call('rssr_rss_varbvsr_update', PACKAGE = 'rssr', betahat, se, sigma_beta, SiRiS_snp, SiRiSr, SiRiSr_snp, logodds, alpha, mu))
}

SiRSi <- function(R, Si) {
    .Call('rssr_SiRSi', PACKAGE = 'rssr', R, Si)
}

genSymm <- function(R) {
    .Call('rssr_genSymm', PACKAGE = 'rssr', R)
}

#' Single update of RSS with variational method
#' This function is a very close translation of the original implementation of RSS. It is kept here for testing purposes
#' It performs a single update
rss_varbvsr_iter_naive_reference <- function(SiRiS, sigma_beta, logodds, betahat, se, alpha0, mu0, SiRiSr0, reverse) {
    .Call('rssr_rss_varbvsr_iter_naive_reference', PACKAGE = 'rssr', SiRiS, sigma_beta, logodds, betahat, se, alpha0, mu0, SiRiSr0, reverse)
}

